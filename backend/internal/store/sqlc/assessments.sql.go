// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: assessments.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clusterCounts = `-- name: ClusterCounts :many
SELECT COALESCE(cluster, '') AS cluster, COUNT(*) AS count
FROM assessments
GROUP BY COALESCE(cluster, '')
`

type ClusterCountsRow struct {
	Cluster string `json:"cluster"`
	Count   int64  `json:"count"`
}

func (q *Queries) ClusterCounts(ctx context.Context) ([]ClusterCountsRow, error) {
	rows, err := q.db.Query(ctx, clusterCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClusterCountsRow
	for rows.Next() {
		var i ClusterCountsRow
		if err := rows.Scan(&i.Cluster, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const clusterCountsByUser = `-- name: ClusterCountsByUser :many
SELECT COALESCE(cluster, '') AS cluster, COUNT(*) AS count
FROM assessments
WHERE user_id = $1
GROUP BY COALESCE(cluster, '')
`

type ClusterCountsByUserRow struct {
	Cluster string `json:"cluster"`
	Count   int64  `json:"count"`
}

func (q *Queries) ClusterCountsByUser(ctx context.Context, userID pgtype.Int4) ([]ClusterCountsByUserRow, error) {
	rows, err := q.db.Query(ctx, clusterCountsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClusterCountsByUserRow
	for rows.Next() {
		var i ClusterCountsByUserRow
		if err := rows.Scan(&i.Cluster, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countAssessmentsByUser = `-- name: CountAssessmentsByUser :one
SELECT COUNT(*) FROM assessments WHERE user_id = $1
`

func (q *Queries) CountAssessmentsByUser(ctx context.Context, userID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countAssessmentsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAssessment = `-- name: CreateAssessment :one
INSERT INTO assessments (
   user_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
   activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
   model_version, dataset_hash, validation_status, is_self_reported, source, notes
) VALUES (
   $1, $2, $3, $4, $5, $6, $7, $8, $9,
   $10, $11, $12, $13, $14, $15, $16, $17, $18,
   $19, $20, $21, $22, $23
)
RETURNING id, user_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
           activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
           model_version, dataset_hash, validation_status, is_self_reported, source, notes, created_at, updated_at
`

type CreateAssessmentParams struct {
	UserID           pgtype.Int4    `json:"user_id"`
	Fbs              pgtype.Numeric `json:"fbs"`
	Hba1c            pgtype.Numeric `json:"hba1c"`
	Cholesterol      pgtype.Int4    `json:"cholesterol"`
	Ldl              pgtype.Int4    `json:"ldl"`
	Hdl              pgtype.Int4    `json:"hdl"`
	Triglycerides    pgtype.Int4    `json:"triglycerides"`
	Systolic         pgtype.Int4    `json:"systolic"`
	Diastolic        pgtype.Int4    `json:"diastolic"`
	Activity         pgtype.Text    `json:"activity"`
	HistoryFlag      pgtype.Bool    `json:"history_flag"`
	Smoking          pgtype.Text    `json:"smoking"`
	Hypertension     pgtype.Text    `json:"hypertension"`
	HeartDisease     pgtype.Text    `json:"heart_disease"`
	Bmi              pgtype.Numeric `json:"bmi"`
	Cluster          pgtype.Text    `json:"cluster"`
	RiskScore        pgtype.Int4    `json:"risk_score"`
	ModelVersion     pgtype.Text    `json:"model_version"`
	DatasetHash      pgtype.Text    `json:"dataset_hash"`
	ValidationStatus pgtype.Text    `json:"validation_status"`
	IsSelfReported   pgtype.Bool    `json:"is_self_reported"`
	Source           pgtype.Text    `json:"source"`
	Notes            pgtype.Text    `json:"notes"`
}

type CreateAssessmentRow struct {
	ID               int32              `json:"id"`
	UserID           pgtype.Int4        `json:"user_id"`
	Fbs              pgtype.Numeric     `json:"fbs"`
	Hba1c            pgtype.Numeric     `json:"hba1c"`
	Cholesterol      pgtype.Int4        `json:"cholesterol"`
	Ldl              pgtype.Int4        `json:"ldl"`
	Hdl              pgtype.Int4        `json:"hdl"`
	Triglycerides    pgtype.Int4        `json:"triglycerides"`
	Systolic         pgtype.Int4        `json:"systolic"`
	Diastolic        pgtype.Int4        `json:"diastolic"`
	Activity         pgtype.Text        `json:"activity"`
	HistoryFlag      pgtype.Bool        `json:"history_flag"`
	Smoking          pgtype.Text        `json:"smoking"`
	Hypertension     pgtype.Text        `json:"hypertension"`
	HeartDisease     pgtype.Text        `json:"heart_disease"`
	Bmi              pgtype.Numeric     `json:"bmi"`
	Cluster          pgtype.Text        `json:"cluster"`
	RiskScore        pgtype.Int4        `json:"risk_score"`
	ModelVersion     pgtype.Text        `json:"model_version"`
	DatasetHash      pgtype.Text        `json:"dataset_hash"`
	ValidationStatus pgtype.Text        `json:"validation_status"`
	IsSelfReported   bool               `json:"is_self_reported"`
	Source           string             `json:"source"`
	Notes            pgtype.Text        `json:"notes"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateAssessment(ctx context.Context, arg CreateAssessmentParams) (CreateAssessmentRow, error) {
	row := q.db.QueryRow(ctx, createAssessment,
		arg.UserID,
		arg.Fbs,
		arg.Hba1c,
		arg.Cholesterol,
		arg.Ldl,
		arg.Hdl,
		arg.Triglycerides,
		arg.Systolic,
		arg.Diastolic,
		arg.Activity,
		arg.HistoryFlag,
		arg.Smoking,
		arg.Hypertension,
		arg.HeartDisease,
		arg.Bmi,
		arg.Cluster,
		arg.RiskScore,
		arg.ModelVersion,
		arg.DatasetHash,
		arg.ValidationStatus,
		arg.IsSelfReported,
		arg.Source,
		arg.Notes,
	)
	var i CreateAssessmentRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Fbs,
		&i.Hba1c,
		&i.Cholesterol,
		&i.Ldl,
		&i.Hdl,
		&i.Triglycerides,
		&i.Systolic,
		&i.Diastolic,
		&i.Activity,
		&i.HistoryFlag,
		&i.Smoking,
		&i.Hypertension,
		&i.HeartDisease,
		&i.Bmi,
		&i.Cluster,
		&i.RiskScore,
		&i.ModelVersion,
		&i.DatasetHash,
		&i.ValidationStatus,
		&i.IsSelfReported,
		&i.Source,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAssessment = `-- name: DeleteAssessment :exec
DELETE FROM assessments
WHERE id = $1
`

func (q *Queries) DeleteAssessment(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAssessment, id)
	return err
}

const getAssessment = `-- name: GetAssessment :one
SELECT id, user_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
    activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
    model_version, dataset_hash, validation_status, is_self_reported, source, notes, created_at, updated_at
FROM assessments
WHERE id = $1
LIMIT 1
`

type GetAssessmentRow struct {
	ID               int32              `json:"id"`
	UserID           pgtype.Int4        `json:"user_id"`
	Fbs              pgtype.Numeric     `json:"fbs"`
	Hba1c            pgtype.Numeric     `json:"hba1c"`
	Cholesterol      pgtype.Int4        `json:"cholesterol"`
	Ldl              pgtype.Int4        `json:"ldl"`
	Hdl              pgtype.Int4        `json:"hdl"`
	Triglycerides    pgtype.Int4        `json:"triglycerides"`
	Systolic         pgtype.Int4        `json:"systolic"`
	Diastolic        pgtype.Int4        `json:"diastolic"`
	Activity         pgtype.Text        `json:"activity"`
	HistoryFlag      pgtype.Bool        `json:"history_flag"`
	Smoking          pgtype.Text        `json:"smoking"`
	Hypertension     pgtype.Text        `json:"hypertension"`
	HeartDisease     pgtype.Text        `json:"heart_disease"`
	Bmi              pgtype.Numeric     `json:"bmi"`
	Cluster          pgtype.Text        `json:"cluster"`
	RiskScore        pgtype.Int4        `json:"risk_score"`
	ModelVersion     pgtype.Text        `json:"model_version"`
	DatasetHash      pgtype.Text        `json:"dataset_hash"`
	ValidationStatus pgtype.Text        `json:"validation_status"`
	IsSelfReported   bool               `json:"is_self_reported"`
	Source           string             `json:"source"`
	Notes            pgtype.Text        `json:"notes"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetAssessment(ctx context.Context, id int32) (GetAssessmentRow, error) {
	row := q.db.QueryRow(ctx, getAssessment, id)
	var i GetAssessmentRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Fbs,
		&i.Hba1c,
		&i.Cholesterol,
		&i.Ldl,
		&i.Hdl,
		&i.Triglycerides,
		&i.Systolic,
		&i.Diastolic,
		&i.Activity,
		&i.HistoryFlag,
		&i.Smoking,
		&i.Hypertension,
		&i.HeartDisease,
		&i.Bmi,
		&i.Cluster,
		&i.RiskScore,
		&i.ModelVersion,
		&i.DatasetHash,
		&i.ValidationStatus,
		&i.IsSelfReported,
		&i.Source,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAssessmentTrendByUser = `-- name: GetAssessmentTrendByUser :many
SELECT id, created_at, risk_score, cluster, hba1c, bmi, fbs, 
    triglycerides, ldl, hdl
FROM assessments
WHERE user_id = $1
ORDER BY created_at ASC
`

type GetAssessmentTrendByUserRow struct {
	ID            int32              `json:"id"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	RiskScore     pgtype.Int4        `json:"risk_score"`
	Cluster       pgtype.Text        `json:"cluster"`
	Hba1c         pgtype.Numeric     `json:"hba1c"`
	Bmi           pgtype.Numeric     `json:"bmi"`
	Fbs           pgtype.Numeric     `json:"fbs"`
	Triglycerides pgtype.Int4        `json:"triglycerides"`
	Ldl           pgtype.Int4        `json:"ldl"`
	Hdl           pgtype.Int4        `json:"hdl"`
}

func (q *Queries) GetAssessmentTrendByUser(ctx context.Context, userID pgtype.Int4) ([]GetAssessmentTrendByUserRow, error) {
	rows, err := q.db.Query(ctx, getAssessmentTrendByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssessmentTrendByUserRow
	for rows.Next() {
		var i GetAssessmentTrendByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.RiskScore,
			&i.Cluster,
			&i.Hba1c,
			&i.Bmi,
			&i.Fbs,
			&i.Triglycerides,
			&i.Ldl,
			&i.Hdl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestAssessmentByUser = `-- name: GetLatestAssessmentByUser :one
SELECT id, user_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
    activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
    model_version, dataset_hash, validation_status, is_self_reported, source, notes, created_at, updated_at
FROM assessments
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT 1
`

type GetLatestAssessmentByUserRow struct {
	ID               int32              `json:"id"`
	UserID           pgtype.Int4        `json:"user_id"`
	Fbs              pgtype.Numeric     `json:"fbs"`
	Hba1c            pgtype.Numeric     `json:"hba1c"`
	Cholesterol      pgtype.Int4        `json:"cholesterol"`
	Ldl              pgtype.Int4        `json:"ldl"`
	Hdl              pgtype.Int4        `json:"hdl"`
	Triglycerides    pgtype.Int4        `json:"triglycerides"`
	Systolic         pgtype.Int4        `json:"systolic"`
	Diastolic        pgtype.Int4        `json:"diastolic"`
	Activity         pgtype.Text        `json:"activity"`
	HistoryFlag      pgtype.Bool        `json:"history_flag"`
	Smoking          pgtype.Text        `json:"smoking"`
	Hypertension     pgtype.Text        `json:"hypertension"`
	HeartDisease     pgtype.Text        `json:"heart_disease"`
	Bmi              pgtype.Numeric     `json:"bmi"`
	Cluster          pgtype.Text        `json:"cluster"`
	RiskScore        pgtype.Int4        `json:"risk_score"`
	ModelVersion     pgtype.Text        `json:"model_version"`
	DatasetHash      pgtype.Text        `json:"dataset_hash"`
	ValidationStatus pgtype.Text        `json:"validation_status"`
	IsSelfReported   bool               `json:"is_self_reported"`
	Source           string             `json:"source"`
	Notes            pgtype.Text        `json:"notes"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetLatestAssessmentByUser(ctx context.Context, userID pgtype.Int4) (GetLatestAssessmentByUserRow, error) {
	row := q.db.QueryRow(ctx, getLatestAssessmentByUser, userID)
	var i GetLatestAssessmentByUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Fbs,
		&i.Hba1c,
		&i.Cholesterol,
		&i.Ldl,
		&i.Hdl,
		&i.Triglycerides,
		&i.Systolic,
		&i.Diastolic,
		&i.Activity,
		&i.HistoryFlag,
		&i.Smoking,
		&i.Hypertension,
		&i.HeartDisease,
		&i.Bmi,
		&i.Cluster,
		&i.RiskScore,
		&i.ModelVersion,
		&i.DatasetHash,
		&i.ValidationStatus,
		&i.IsSelfReported,
		&i.Source,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLatestAssessmentDateByUser = `-- name: GetLatestAssessmentDateByUser :one
SELECT created_at FROM assessments
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestAssessmentDateByUser(ctx context.Context, userID pgtype.Int4) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getLatestAssessmentDateByUser, userID)
	var created_at pgtype.Timestamptz
	err := row.Scan(&created_at)
	return created_at, err
}

const listAssessmentsByUser = `-- name: ListAssessmentsByUser :many
SELECT id, user_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
    activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
    model_version, dataset_hash, validation_status, is_self_reported, source, notes, created_at, updated_at
FROM assessments
WHERE user_id = $1
ORDER BY created_at DESC
`

type ListAssessmentsByUserRow struct {
	ID               int32              `json:"id"`
	UserID           pgtype.Int4        `json:"user_id"`
	Fbs              pgtype.Numeric     `json:"fbs"`
	Hba1c            pgtype.Numeric     `json:"hba1c"`
	Cholesterol      pgtype.Int4        `json:"cholesterol"`
	Ldl              pgtype.Int4        `json:"ldl"`
	Hdl              pgtype.Int4        `json:"hdl"`
	Triglycerides    pgtype.Int4        `json:"triglycerides"`
	Systolic         pgtype.Int4        `json:"systolic"`
	Diastolic        pgtype.Int4        `json:"diastolic"`
	Activity         pgtype.Text        `json:"activity"`
	HistoryFlag      pgtype.Bool        `json:"history_flag"`
	Smoking          pgtype.Text        `json:"smoking"`
	Hypertension     pgtype.Text        `json:"hypertension"`
	HeartDisease     pgtype.Text        `json:"heart_disease"`
	Bmi              pgtype.Numeric     `json:"bmi"`
	Cluster          pgtype.Text        `json:"cluster"`
	RiskScore        pgtype.Int4        `json:"risk_score"`
	ModelVersion     pgtype.Text        `json:"model_version"`
	DatasetHash      pgtype.Text        `json:"dataset_hash"`
	ValidationStatus pgtype.Text        `json:"validation_status"`
	IsSelfReported   bool               `json:"is_self_reported"`
	Source           string             `json:"source"`
	Notes            pgtype.Text        `json:"notes"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListAssessmentsByUser(ctx context.Context, userID pgtype.Int4) ([]ListAssessmentsByUserRow, error) {
	rows, err := q.db.Query(ctx, listAssessmentsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAssessmentsByUserRow
	for rows.Next() {
		var i ListAssessmentsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Fbs,
			&i.Hba1c,
			&i.Cholesterol,
			&i.Ldl,
			&i.Hdl,
			&i.Triglycerides,
			&i.Systolic,
			&i.Diastolic,
			&i.Activity,
			&i.HistoryFlag,
			&i.Smoking,
			&i.Hypertension,
			&i.HeartDisease,
			&i.Bmi,
			&i.Cluster,
			&i.RiskScore,
			&i.ModelVersion,
			&i.DatasetHash,
			&i.ValidationStatus,
			&i.IsSelfReported,
			&i.Source,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssessmentsByUserPaginated = `-- name: ListAssessmentsByUserPaginated :many
SELECT id, user_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
    activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
    model_version, dataset_hash, validation_status, is_self_reported, source, notes, created_at, updated_at
FROM assessments
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAssessmentsByUserPaginatedParams struct {
	UserID pgtype.Int4 `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type ListAssessmentsByUserPaginatedRow struct {
	ID               int32              `json:"id"`
	UserID           pgtype.Int4        `json:"user_id"`
	Fbs              pgtype.Numeric     `json:"fbs"`
	Hba1c            pgtype.Numeric     `json:"hba1c"`
	Cholesterol      pgtype.Int4        `json:"cholesterol"`
	Ldl              pgtype.Int4        `json:"ldl"`
	Hdl              pgtype.Int4        `json:"hdl"`
	Triglycerides    pgtype.Int4        `json:"triglycerides"`
	Systolic         pgtype.Int4        `json:"systolic"`
	Diastolic        pgtype.Int4        `json:"diastolic"`
	Activity         pgtype.Text        `json:"activity"`
	HistoryFlag      pgtype.Bool        `json:"history_flag"`
	Smoking          pgtype.Text        `json:"smoking"`
	Hypertension     pgtype.Text        `json:"hypertension"`
	HeartDisease     pgtype.Text        `json:"heart_disease"`
	Bmi              pgtype.Numeric     `json:"bmi"`
	Cluster          pgtype.Text        `json:"cluster"`
	RiskScore        pgtype.Int4        `json:"risk_score"`
	ModelVersion     pgtype.Text        `json:"model_version"`
	DatasetHash      pgtype.Text        `json:"dataset_hash"`
	ValidationStatus pgtype.Text        `json:"validation_status"`
	IsSelfReported   bool               `json:"is_self_reported"`
	Source           string             `json:"source"`
	Notes            pgtype.Text        `json:"notes"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListAssessmentsByUserPaginated(ctx context.Context, arg ListAssessmentsByUserPaginatedParams) ([]ListAssessmentsByUserPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listAssessmentsByUserPaginated, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAssessmentsByUserPaginatedRow
	for rows.Next() {
		var i ListAssessmentsByUserPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Fbs,
			&i.Hba1c,
			&i.Cholesterol,
			&i.Ldl,
			&i.Hdl,
			&i.Triglycerides,
			&i.Systolic,
			&i.Diastolic,
			&i.Activity,
			&i.HistoryFlag,
			&i.Smoking,
			&i.Hypertension,
			&i.HeartDisease,
			&i.Bmi,
			&i.Cluster,
			&i.RiskScore,
			&i.ModelVersion,
			&i.DatasetHash,
			&i.ValidationStatus,
			&i.IsSelfReported,
			&i.Source,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssessmentsLimited = `-- name: ListAssessmentsLimited :many
SELECT id, user_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
    activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
    model_version, dataset_hash, validation_status, is_self_reported, source, notes, created_at, updated_at
FROM assessments
ORDER BY created_at DESC
LIMIT $1
`

type ListAssessmentsLimitedRow struct {
	ID               int32              `json:"id"`
	UserID           pgtype.Int4        `json:"user_id"`
	Fbs              pgtype.Numeric     `json:"fbs"`
	Hba1c            pgtype.Numeric     `json:"hba1c"`
	Cholesterol      pgtype.Int4        `json:"cholesterol"`
	Ldl              pgtype.Int4        `json:"ldl"`
	Hdl              pgtype.Int4        `json:"hdl"`
	Triglycerides    pgtype.Int4        `json:"triglycerides"`
	Systolic         pgtype.Int4        `json:"systolic"`
	Diastolic        pgtype.Int4        `json:"diastolic"`
	Activity         pgtype.Text        `json:"activity"`
	HistoryFlag      pgtype.Bool        `json:"history_flag"`
	Smoking          pgtype.Text        `json:"smoking"`
	Hypertension     pgtype.Text        `json:"hypertension"`
	HeartDisease     pgtype.Text        `json:"heart_disease"`
	Bmi              pgtype.Numeric     `json:"bmi"`
	Cluster          pgtype.Text        `json:"cluster"`
	RiskScore        pgtype.Int4        `json:"risk_score"`
	ModelVersion     pgtype.Text        `json:"model_version"`
	DatasetHash      pgtype.Text        `json:"dataset_hash"`
	ValidationStatus pgtype.Text        `json:"validation_status"`
	IsSelfReported   bool               `json:"is_self_reported"`
	Source           string             `json:"source"`
	Notes            pgtype.Text        `json:"notes"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListAssessmentsLimited(ctx context.Context, limit int32) ([]ListAssessmentsLimitedRow, error) {
	rows, err := q.db.Query(ctx, listAssessmentsLimited, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAssessmentsLimitedRow
	for rows.Next() {
		var i ListAssessmentsLimitedRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Fbs,
			&i.Hba1c,
			&i.Cholesterol,
			&i.Ldl,
			&i.Hdl,
			&i.Triglycerides,
			&i.Systolic,
			&i.Diastolic,
			&i.Activity,
			&i.HistoryFlag,
			&i.Smoking,
			&i.Hypertension,
			&i.HeartDisease,
			&i.Bmi,
			&i.Cluster,
			&i.RiskScore,
			&i.ModelVersion,
			&i.DatasetHash,
			&i.ValidationStatus,
			&i.IsSelfReported,
			&i.Source,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const trendAverages = `-- name: TrendAverages :many
SELECT to_char(created_at, 'YYYY-MM') AS label,
    COALESCE(avg(hba1c), 0)::float8 AS hba1c,
    COALESCE(avg(fbs), 0)::float8 AS fbs
FROM assessments
GROUP BY label
ORDER BY label
`

type TrendAveragesRow struct {
	Label string  `json:"label"`
	Hba1c float64 `json:"hba1c"`
	Fbs   float64 `json:"fbs"`
}

func (q *Queries) TrendAverages(ctx context.Context) ([]TrendAveragesRow, error) {
	rows, err := q.db.Query(ctx, trendAverages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TrendAveragesRow
	for rows.Next() {
		var i TrendAveragesRow
		if err := rows.Scan(&i.Label, &i.Hba1c, &i.Fbs); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const trendAveragesByUser = `-- name: TrendAveragesByUser :many
SELECT to_char(created_at, 'YYYY-MM') AS label,
    COALESCE(avg(hba1c), 0)::float8 AS hba1c,
    COALESCE(avg(fbs), 0)::float8 AS fbs
FROM assessments
WHERE user_id = $1
GROUP BY label
ORDER BY label
`

type TrendAveragesByUserRow struct {
	Label string  `json:"label"`
	Hba1c float64 `json:"hba1c"`
	Fbs   float64 `json:"fbs"`
}

func (q *Queries) TrendAveragesByUser(ctx context.Context, userID pgtype.Int4) ([]TrendAveragesByUserRow, error) {
	rows, err := q.db.Query(ctx, trendAveragesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TrendAveragesByUserRow
	for rows.Next() {
		var i TrendAveragesByUserRow
		if err := rows.Scan(&i.Label, &i.Hba1c, &i.Fbs); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssessment = `-- name: UpdateAssessment :one
UPDATE assessments
SET user_id = $1,
    fbs = $2,
    hba1c = $3,
    cholesterol = $4,
    ldl = $5,
    hdl = $6,
    triglycerides = $7,
    systolic = $8,
    diastolic = $9,
    activity = $10,
    history_flag = $11,
    smoking = $12,
    hypertension = $13,
    heart_disease = $14,
    bmi = $15,
    cluster = $16,
    risk_score = $17,
    model_version = $18,
    dataset_hash = $19,
    validation_status = $20,
    notes = $21,
    updated_at = NOW()
WHERE id = $22
RETURNING id, user_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
          activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
          model_version, dataset_hash, validation_status, is_self_reported, source, notes, created_at, updated_at
`

type UpdateAssessmentParams struct {
	UserID           pgtype.Int4    `json:"user_id"`
	Fbs              pgtype.Numeric `json:"fbs"`
	Hba1c            pgtype.Numeric `json:"hba1c"`
	Cholesterol      pgtype.Int4    `json:"cholesterol"`
	Ldl              pgtype.Int4    `json:"ldl"`
	Hdl              pgtype.Int4    `json:"hdl"`
	Triglycerides    pgtype.Int4    `json:"triglycerides"`
	Systolic         pgtype.Int4    `json:"systolic"`
	Diastolic        pgtype.Int4    `json:"diastolic"`
	Activity         pgtype.Text    `json:"activity"`
	HistoryFlag      pgtype.Bool    `json:"history_flag"`
	Smoking          pgtype.Text    `json:"smoking"`
	Hypertension     pgtype.Text    `json:"hypertension"`
	HeartDisease     pgtype.Text    `json:"heart_disease"`
	Bmi              pgtype.Numeric `json:"bmi"`
	Cluster          pgtype.Text    `json:"cluster"`
	RiskScore        pgtype.Int4    `json:"risk_score"`
	ModelVersion     pgtype.Text    `json:"model_version"`
	DatasetHash      pgtype.Text    `json:"dataset_hash"`
	ValidationStatus pgtype.Text    `json:"validation_status"`
	Notes            pgtype.Text    `json:"notes"`
	ID               int32          `json:"id"`
}

type UpdateAssessmentRow struct {
	ID               int32              `json:"id"`
	UserID           pgtype.Int4        `json:"user_id"`
	Fbs              pgtype.Numeric     `json:"fbs"`
	Hba1c            pgtype.Numeric     `json:"hba1c"`
	Cholesterol      pgtype.Int4        `json:"cholesterol"`
	Ldl              pgtype.Int4        `json:"ldl"`
	Hdl              pgtype.Int4        `json:"hdl"`
	Triglycerides    pgtype.Int4        `json:"triglycerides"`
	Systolic         pgtype.Int4        `json:"systolic"`
	Diastolic        pgtype.Int4        `json:"diastolic"`
	Activity         pgtype.Text        `json:"activity"`
	HistoryFlag      pgtype.Bool        `json:"history_flag"`
	Smoking          pgtype.Text        `json:"smoking"`
	Hypertension     pgtype.Text        `json:"hypertension"`
	HeartDisease     pgtype.Text        `json:"heart_disease"`
	Bmi              pgtype.Numeric     `json:"bmi"`
	Cluster          pgtype.Text        `json:"cluster"`
	RiskScore        pgtype.Int4        `json:"risk_score"`
	ModelVersion     pgtype.Text        `json:"model_version"`
	DatasetHash      pgtype.Text        `json:"dataset_hash"`
	ValidationStatus pgtype.Text        `json:"validation_status"`
	IsSelfReported   bool               `json:"is_self_reported"`
	Source           string             `json:"source"`
	Notes            pgtype.Text        `json:"notes"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateAssessment(ctx context.Context, arg UpdateAssessmentParams) (UpdateAssessmentRow, error) {
	row := q.db.QueryRow(ctx, updateAssessment,
		arg.UserID,
		arg.Fbs,
		arg.Hba1c,
		arg.Cholesterol,
		arg.Ldl,
		arg.Hdl,
		arg.Triglycerides,
		arg.Systolic,
		arg.Diastolic,
		arg.Activity,
		arg.HistoryFlag,
		arg.Smoking,
		arg.Hypertension,
		arg.HeartDisease,
		arg.Bmi,
		arg.Cluster,
		arg.RiskScore,
		arg.ModelVersion,
		arg.DatasetHash,
		arg.ValidationStatus,
		arg.Notes,
		arg.ID,
	)
	var i UpdateAssessmentRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Fbs,
		&i.Hba1c,
		&i.Cholesterol,
		&i.Ldl,
		&i.Hdl,
		&i.Triglycerides,
		&i.Systolic,
		&i.Diastolic,
		&i.Activity,
		&i.HistoryFlag,
		&i.Smoking,
		&i.Hypertension,
		&i.HeartDisease,
		&i.Bmi,
		&i.Cluster,
		&i.RiskScore,
		&i.ModelVersion,
		&i.DatasetHash,
		&i.ValidationStatus,
		&i.IsSelfReported,
		&i.Source,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
