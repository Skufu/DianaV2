// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: assessments.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clusterCounts = `-- name: ClusterCounts :many
SELECT COALESCE(cluster, '') AS cluster, COUNT(*) AS count
FROM assessments
GROUP BY COALESCE(cluster, '')
`

type ClusterCountsRow struct {
	Cluster string `json:"cluster"`
	Count   int64  `json:"count"`
}

func (q *Queries) ClusterCounts(ctx context.Context) ([]ClusterCountsRow, error) {
	rows, err := q.db.Query(ctx, clusterCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClusterCountsRow
	for rows.Next() {
		var i ClusterCountsRow
		if err := rows.Scan(&i.Cluster, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const clusterCountsByUser = `-- name: ClusterCountsByUser :many
SELECT COALESCE(a.cluster, '') AS cluster, COUNT(*) AS count
FROM assessments a
INNER JOIN patients p ON a.patient_id = p.id
WHERE p.user_id = $1
GROUP BY COALESCE(a.cluster, '')
`

type ClusterCountsByUserRow struct {
	Cluster string `json:"cluster"`
	Count   int64  `json:"count"`
}

func (q *Queries) ClusterCountsByUser(ctx context.Context, userID int32) ([]ClusterCountsByUserRow, error) {
	rows, err := q.db.Query(ctx, clusterCountsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClusterCountsByUserRow
	for rows.Next() {
		var i ClusterCountsByUserRow
		if err := rows.Scan(&i.Cluster, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createAssessment = `-- name: CreateAssessment :one
INSERT INTO assessments (
  patient_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
  activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
  model_version, dataset_hash, validation_status
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9,
  $10, $11, $12, $13, $14, $15, $16, $17,
  $18, $19, $20
)
RETURNING id, patient_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
          activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
          model_version, dataset_hash, validation_status, created_at, updated_at
`

type CreateAssessmentParams struct {
	PatientID        pgtype.Int4    `json:"patient_id"`
	Fbs              pgtype.Numeric `json:"fbs"`
	Hba1c            pgtype.Numeric `json:"hba1c"`
	Cholesterol      pgtype.Int4    `json:"cholesterol"`
	Ldl              pgtype.Int4    `json:"ldl"`
	Hdl              pgtype.Int4    `json:"hdl"`
	Triglycerides    pgtype.Int4    `json:"triglycerides"`
	Systolic         pgtype.Int4    `json:"systolic"`
	Diastolic        pgtype.Int4    `json:"diastolic"`
	Activity         pgtype.Text    `json:"activity"`
	HistoryFlag      pgtype.Bool    `json:"history_flag"`
	Smoking          pgtype.Text    `json:"smoking"`
	Hypertension     pgtype.Text    `json:"hypertension"`
	HeartDisease     pgtype.Text    `json:"heart_disease"`
	Bmi              pgtype.Numeric `json:"bmi"`
	Cluster          pgtype.Text    `json:"cluster"`
	RiskScore        pgtype.Int4    `json:"risk_score"`
	ModelVersion     pgtype.Text    `json:"model_version"`
	DatasetHash      pgtype.Text    `json:"dataset_hash"`
	ValidationStatus pgtype.Text    `json:"validation_status"`
}

func (q *Queries) CreateAssessment(ctx context.Context, arg CreateAssessmentParams) (Assessment, error) {
	row := q.db.QueryRow(ctx, createAssessment,
		arg.PatientID,
		arg.Fbs,
		arg.Hba1c,
		arg.Cholesterol,
		arg.Ldl,
		arg.Hdl,
		arg.Triglycerides,
		arg.Systolic,
		arg.Diastolic,
		arg.Activity,
		arg.HistoryFlag,
		arg.Smoking,
		arg.Hypertension,
		arg.HeartDisease,
		arg.Bmi,
		arg.Cluster,
		arg.RiskScore,
		arg.ModelVersion,
		arg.DatasetHash,
		arg.ValidationStatus,
	)
	var i Assessment
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.Fbs,
		&i.Hba1c,
		&i.Cholesterol,
		&i.Ldl,
		&i.Hdl,
		&i.Triglycerides,
		&i.Systolic,
		&i.Diastolic,
		&i.Activity,
		&i.HistoryFlag,
		&i.Smoking,
		&i.Hypertension,
		&i.HeartDisease,
		&i.Bmi,
		&i.Cluster,
		&i.RiskScore,
		&i.ModelVersion,
		&i.DatasetHash,
		&i.ValidationStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAssessment = `-- name: DeleteAssessment :exec
DELETE FROM assessments
WHERE id = $1
`

func (q *Queries) DeleteAssessment(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAssessment, id)
	return err
}

const getAssessment = `-- name: GetAssessment :one
SELECT id, patient_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
       activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
       model_version, dataset_hash, validation_status, created_at, updated_at
FROM assessments
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetAssessment(ctx context.Context, id int32) (Assessment, error) {
	row := q.db.QueryRow(ctx, getAssessment, id)
	var i Assessment
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.Fbs,
		&i.Hba1c,
		&i.Cholesterol,
		&i.Ldl,
		&i.Hdl,
		&i.Triglycerides,
		&i.Systolic,
		&i.Diastolic,
		&i.Activity,
		&i.HistoryFlag,
		&i.Smoking,
		&i.Hypertension,
		&i.HeartDisease,
		&i.Bmi,
		&i.Cluster,
		&i.RiskScore,
		&i.ModelVersion,
		&i.DatasetHash,
		&i.ValidationStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPatientAssessmentTrend = `-- name: GetPatientAssessmentTrend :many
SELECT id, created_at, risk_score, cluster, hba1c, bmi, fbs, 
       triglycerides, ldl, hdl
FROM assessments
WHERE patient_id = $1
ORDER BY created_at ASC
`

type GetPatientAssessmentTrendRow struct {
	ID            int32              `json:"id"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	RiskScore     pgtype.Int4        `json:"risk_score"`
	Cluster       pgtype.Text        `json:"cluster"`
	Hba1c         pgtype.Numeric     `json:"hba1c"`
	Bmi           pgtype.Numeric     `json:"bmi"`
	Fbs           pgtype.Numeric     `json:"fbs"`
	Triglycerides pgtype.Int4        `json:"triglycerides"`
	Ldl           pgtype.Int4        `json:"ldl"`
	Hdl           pgtype.Int4        `json:"hdl"`
}

func (q *Queries) GetPatientAssessmentTrend(ctx context.Context, patientID pgtype.Int4) ([]GetPatientAssessmentTrendRow, error) {
	rows, err := q.db.Query(ctx, getPatientAssessmentTrend, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPatientAssessmentTrendRow
	for rows.Next() {
		var i GetPatientAssessmentTrendRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.RiskScore,
			&i.Cluster,
			&i.Hba1c,
			&i.Bmi,
			&i.Fbs,
			&i.Triglycerides,
			&i.Ldl,
			&i.Hdl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssessmentsByPatient = `-- name: ListAssessmentsByPatient :many
SELECT id, patient_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
       activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
       model_version, dataset_hash, validation_status, created_at, updated_at
FROM assessments
WHERE patient_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAssessmentsByPatient(ctx context.Context, patientID pgtype.Int4) ([]Assessment, error) {
	rows, err := q.db.Query(ctx, listAssessmentsByPatient, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Assessment
	for rows.Next() {
		var i Assessment
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.Fbs,
			&i.Hba1c,
			&i.Cholesterol,
			&i.Ldl,
			&i.Hdl,
			&i.Triglycerides,
			&i.Systolic,
			&i.Diastolic,
			&i.Activity,
			&i.HistoryFlag,
			&i.Smoking,
			&i.Hypertension,
			&i.HeartDisease,
			&i.Bmi,
			&i.Cluster,
			&i.RiskScore,
			&i.ModelVersion,
			&i.DatasetHash,
			&i.ValidationStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssessmentsLimited = `-- name: ListAssessmentsLimited :many
SELECT id, patient_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
       activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
       model_version, dataset_hash, validation_status, created_at, updated_at
FROM assessments
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) ListAssessmentsLimited(ctx context.Context, limit int32) ([]Assessment, error) {
	rows, err := q.db.Query(ctx, listAssessmentsLimited, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Assessment
	for rows.Next() {
		var i Assessment
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.Fbs,
			&i.Hba1c,
			&i.Cholesterol,
			&i.Ldl,
			&i.Hdl,
			&i.Triglycerides,
			&i.Systolic,
			&i.Diastolic,
			&i.Activity,
			&i.HistoryFlag,
			&i.Smoking,
			&i.Hypertension,
			&i.HeartDisease,
			&i.Bmi,
			&i.Cluster,
			&i.RiskScore,
			&i.ModelVersion,
			&i.DatasetHash,
			&i.ValidationStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssessmentsLimitedByUser = `-- name: ListAssessmentsLimitedByUser :many
SELECT a.id, a.patient_id, a.fbs, a.hba1c, a.cholesterol, a.ldl, a.hdl, a.triglycerides,
       a.systolic, a.diastolic, a.activity, a.history_flag, a.smoking, a.hypertension,
       a.heart_disease, a.bmi, a.cluster, a.risk_score, a.model_version, a.dataset_hash,
       a.validation_status, a.created_at, a.updated_at
FROM assessments a
INNER JOIN patients p ON a.patient_id = p.id
WHERE p.user_id = $1
ORDER BY a.created_at DESC
LIMIT $2
`

type ListAssessmentsLimitedByUserParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) ListAssessmentsLimitedByUser(ctx context.Context, arg ListAssessmentsLimitedByUserParams) ([]Assessment, error) {
	rows, err := q.db.Query(ctx, listAssessmentsLimitedByUser, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Assessment
	for rows.Next() {
		var i Assessment
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.Fbs,
			&i.Hba1c,
			&i.Cholesterol,
			&i.Ldl,
			&i.Hdl,
			&i.Triglycerides,
			&i.Systolic,
			&i.Diastolic,
			&i.Activity,
			&i.HistoryFlag,
			&i.Smoking,
			&i.Hypertension,
			&i.HeartDisease,
			&i.Bmi,
			&i.Cluster,
			&i.RiskScore,
			&i.ModelVersion,
			&i.DatasetHash,
			&i.ValidationStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const trendAverages = `-- name: TrendAverages :many
SELECT to_char(created_at, 'YYYY-MM') AS label,
       COALESCE(avg(hba1c), 0)::float8 AS hba1c,
       COALESCE(avg(fbs), 0)::float8 AS fbs
FROM assessments
GROUP BY label
ORDER BY label
`

type TrendAveragesRow struct {
	Label string  `json:"label"`
	Hba1c float64 `json:"hba1c"`
	Fbs   float64 `json:"fbs"`
}

func (q *Queries) TrendAverages(ctx context.Context) ([]TrendAveragesRow, error) {
	rows, err := q.db.Query(ctx, trendAverages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TrendAveragesRow
	for rows.Next() {
		var i TrendAveragesRow
		if err := rows.Scan(&i.Label, &i.Hba1c, &i.Fbs); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const trendAveragesByUser = `-- name: TrendAveragesByUser :many
SELECT to_char(a.created_at, 'YYYY-MM') AS label,
       COALESCE(avg(a.hba1c), 0)::float8 AS hba1c,
       COALESCE(avg(a.fbs), 0)::float8 AS fbs
FROM assessments a
INNER JOIN patients p ON a.patient_id = p.id
WHERE p.user_id = $1
GROUP BY label
ORDER BY label
`

type TrendAveragesByUserRow struct {
	Label string  `json:"label"`
	Hba1c float64 `json:"hba1c"`
	Fbs   float64 `json:"fbs"`
}

func (q *Queries) TrendAveragesByUser(ctx context.Context, userID int32) ([]TrendAveragesByUserRow, error) {
	rows, err := q.db.Query(ctx, trendAveragesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TrendAveragesByUserRow
	for rows.Next() {
		var i TrendAveragesByUserRow
		if err := rows.Scan(&i.Label, &i.Hba1c, &i.Fbs); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssessment = `-- name: UpdateAssessment :one
UPDATE assessments
SET patient_id = $2,
    fbs = $3,
    hba1c = $4,
    cholesterol = $5,
    ldl = $6,
    hdl = $7,
    triglycerides = $8,
    systolic = $9,
    diastolic = $10,
    activity = $11,
    history_flag = $12,
    smoking = $13,
    hypertension = $14,
    heart_disease = $15,
    bmi = $16,
    cluster = $17,
    risk_score = $18,
    model_version = $19,
    dataset_hash = $20,
    validation_status = $21,
    updated_at = NOW()
WHERE id = $1
RETURNING id, patient_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
          activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
          model_version, dataset_hash, validation_status, created_at, updated_at
`

type UpdateAssessmentParams struct {
	ID               int32          `json:"id"`
	PatientID        pgtype.Int4    `json:"patient_id"`
	Fbs              pgtype.Numeric `json:"fbs"`
	Hba1c            pgtype.Numeric `json:"hba1c"`
	Cholesterol      pgtype.Int4    `json:"cholesterol"`
	Ldl              pgtype.Int4    `json:"ldl"`
	Hdl              pgtype.Int4    `json:"hdl"`
	Triglycerides    pgtype.Int4    `json:"triglycerides"`
	Systolic         pgtype.Int4    `json:"systolic"`
	Diastolic        pgtype.Int4    `json:"diastolic"`
	Activity         pgtype.Text    `json:"activity"`
	HistoryFlag      pgtype.Bool    `json:"history_flag"`
	Smoking          pgtype.Text    `json:"smoking"`
	Hypertension     pgtype.Text    `json:"hypertension"`
	HeartDisease     pgtype.Text    `json:"heart_disease"`
	Bmi              pgtype.Numeric `json:"bmi"`
	Cluster          pgtype.Text    `json:"cluster"`
	RiskScore        pgtype.Int4    `json:"risk_score"`
	ModelVersion     pgtype.Text    `json:"model_version"`
	DatasetHash      pgtype.Text    `json:"dataset_hash"`
	ValidationStatus pgtype.Text    `json:"validation_status"`
}

func (q *Queries) UpdateAssessment(ctx context.Context, arg UpdateAssessmentParams) (Assessment, error) {
	row := q.db.QueryRow(ctx, updateAssessment,
		arg.ID,
		arg.PatientID,
		arg.Fbs,
		arg.Hba1c,
		arg.Cholesterol,
		arg.Ldl,
		arg.Hdl,
		arg.Triglycerides,
		arg.Systolic,
		arg.Diastolic,
		arg.Activity,
		arg.HistoryFlag,
		arg.Smoking,
		arg.Hypertension,
		arg.HeartDisease,
		arg.Bmi,
		arg.Cluster,
		arg.RiskScore,
		arg.ModelVersion,
		arg.DatasetHash,
		arg.ValidationStatus,
	)
	var i Assessment
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.Fbs,
		&i.Hba1c,
		&i.Cholesterol,
		&i.Ldl,
		&i.Hdl,
		&i.Triglycerides,
		&i.Systolic,
		&i.Diastolic,
		&i.Activity,
		&i.HistoryFlag,
		&i.Smoking,
		&i.Hypertension,
		&i.HeartDisease,
		&i.Bmi,
		&i.Cluster,
		&i.RiskScore,
		&i.ModelVersion,
		&i.DatasetHash,
		&i.ValidationStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
