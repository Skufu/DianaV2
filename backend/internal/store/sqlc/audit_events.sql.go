// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audit_events.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAuditEvents = `-- name: CountAuditEvents :one
SELECT COUNT(*)
FROM audit_events
WHERE 
    ($1::text = '' OR actor ILIKE '%' || $1 || '%')
    AND ($2::text = '' OR action = $2)
    AND ($3::timestamptz IS NULL OR created_at >= $3)
    AND ($4::timestamptz IS NULL OR created_at <= $4)
`

type CountAuditEventsParams struct {
	Column1 string             `json:"column_1"`
	Column2 string             `json:"column_2"`
	Column3 pgtype.Timestamptz `json:"column_3"`
	Column4 pgtype.Timestamptz `json:"column_4"`
}

func (q *Queries) CountAuditEvents(ctx context.Context, arg CountAuditEventsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditEvents,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditEvent = `-- name: CreateAuditEvent :exec
INSERT INTO audit_events (actor, action, target_type, target_id, details, created_at)
VALUES ($1, $2, $3, $4, $5, NOW())
`

type CreateAuditEventParams struct {
	Actor      pgtype.Text `json:"actor"`
	Action     pgtype.Text `json:"action"`
	TargetType pgtype.Text `json:"target_type"`
	TargetID   pgtype.Int4 `json:"target_id"`
	Details    []byte      `json:"details"`
}

func (q *Queries) CreateAuditEvent(ctx context.Context, arg CreateAuditEventParams) error {
	_, err := q.db.Exec(ctx, createAuditEvent,
		arg.Actor,
		arg.Action,
		arg.TargetType,
		arg.TargetID,
		arg.Details,
	)
	return err
}

const getAuditEventsByActor = `-- name: GetAuditEventsByActor :many
SELECT id, actor, action, target_type, target_id, details, created_at
FROM audit_events
WHERE actor = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetAuditEventsByActorParams struct {
	Actor pgtype.Text `json:"actor"`
	Limit int32       `json:"limit"`
}

func (q *Queries) GetAuditEventsByActor(ctx context.Context, arg GetAuditEventsByActorParams) ([]AuditEvent, error) {
	rows, err := q.db.Query(ctx, getAuditEventsByActor, arg.Actor, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditEvent
	for rows.Next() {
		var i AuditEvent
		if err := rows.Scan(
			&i.ID,
			&i.Actor,
			&i.Action,
			&i.TargetType,
			&i.TargetID,
			&i.Details,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentAuditEvents = `-- name: GetRecentAuditEvents :many
SELECT id, actor, action, target_type, target_id, details, created_at
FROM audit_events
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) GetRecentAuditEvents(ctx context.Context, limit int32) ([]AuditEvent, error) {
	rows, err := q.db.Query(ctx, getRecentAuditEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditEvent
	for rows.Next() {
		var i AuditEvent
		if err := rows.Scan(
			&i.ID,
			&i.Actor,
			&i.Action,
			&i.TargetType,
			&i.TargetID,
			&i.Details,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditEvents = `-- name: ListAuditEvents :many
SELECT id, actor, action, target_type, target_id, details, created_at
FROM audit_events
WHERE 
    ($1::text = '' OR actor ILIKE '%' || $1 || '%')
    AND ($2::text = '' OR action = $2)
    AND ($3::timestamptz IS NULL OR created_at >= $3)
    AND ($4::timestamptz IS NULL OR created_at <= $4)
ORDER BY created_at DESC
LIMIT $5 OFFSET $6
`

type ListAuditEventsParams struct {
	Column1 string             `json:"column_1"`
	Column2 string             `json:"column_2"`
	Column3 pgtype.Timestamptz `json:"column_3"`
	Column4 pgtype.Timestamptz `json:"column_4"`
	Limit   int32              `json:"limit"`
	Offset  int32              `json:"offset"`
}

func (q *Queries) ListAuditEvents(ctx context.Context, arg ListAuditEventsParams) ([]AuditEvent, error) {
	rows, err := q.db.Query(ctx, listAuditEvents,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditEvent
	for rows.Next() {
		var i AuditEvent
		if err := rows.Scan(
			&i.ID,
			&i.Actor,
			&i.Action,
			&i.TargetType,
			&i.TargetID,
			&i.Details,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
