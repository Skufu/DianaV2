// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: clinics.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const adminClinicComparison = `-- name: AdminClinicComparison :many
SELECT 
    c.id AS clinic_id,
    c.name AS clinic_name,
    COUNT(DISTINCT uc.user_id)::int AS patient_count,
    COUNT(a.id)::int AS assessment_count,
    COALESCE(AVG(a.risk_score), 0)::float8 AS avg_risk_score,
    COUNT(CASE WHEN a.risk_score >= 70 THEN 1 END)::int AS high_risk_count
FROM clinics c
LEFT JOIN user_clinics uc ON c.id = uc.clinic_id
LEFT JOIN assessments a ON uc.user_id = a.user_id
GROUP BY c.id, c.name
ORDER BY c.name
`

type AdminClinicComparisonRow struct {
	ClinicID        int32   `json:"clinic_id"`
	ClinicName      string  `json:"clinic_name"`
	PatientCount    int32   `json:"patient_count"`
	AssessmentCount int32   `json:"assessment_count"`
	AvgRiskScore    float64 `json:"avg_risk_score"`
	HighRiskCount   int32   `json:"high_risk_count"`
}

func (q *Queries) AdminClinicComparison(ctx context.Context) ([]AdminClinicComparisonRow, error) {
	rows, err := q.db.Query(ctx, adminClinicComparison)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminClinicComparisonRow
	for rows.Next() {
		var i AdminClinicComparisonRow
		if err := rows.Scan(
			&i.ClinicID,
			&i.ClinicName,
			&i.PatientCount,
			&i.AssessmentCount,
			&i.AvgRiskScore,
			&i.HighRiskCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminSystemStats = `-- name: AdminSystemStats :one
SELECT
    (SELECT COUNT(*) FROM users)::int AS total_users,
    (SELECT COUNT(*) FROM users WHERE role = 'patient')::int AS total_patients,
    (SELECT COUNT(*) FROM assessments)::int AS total_assessments,
    (SELECT COUNT(*) FROM clinics)::int AS total_clinics,
    COALESCE((SELECT AVG(risk_score) FROM assessments), 0)::float8 AS avg_risk_score,
    (SELECT COUNT(*) FROM assessments WHERE risk_score >= 70)::int AS high_risk_count,
    (SELECT COUNT(*) FROM assessments WHERE created_at >= DATE_TRUNC('month', NOW()))::int AS assessments_this_month,
    (SELECT COUNT(*) FROM users WHERE created_at >= DATE_TRUNC('month', NOW()))::int AS new_users_this_month
`

type AdminSystemStatsRow struct {
	TotalUsers           int32   `json:"total_users"`
	TotalPatients        int32   `json:"total_patients"`
	TotalAssessments     int32   `json:"total_assessments"`
	TotalClinics         int32   `json:"total_clinics"`
	AvgRiskScore         float64 `json:"avg_risk_score"`
	HighRiskCount        int32   `json:"high_risk_count"`
	AssessmentsThisMonth int32   `json:"assessments_this_month"`
	NewUsersThisMonth    int32   `json:"new_users_this_month"`
}

func (q *Queries) AdminSystemStats(ctx context.Context) (AdminSystemStatsRow, error) {
	row := q.db.QueryRow(ctx, adminSystemStats)
	var i AdminSystemStatsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.TotalPatients,
		&i.TotalAssessments,
		&i.TotalClinics,
		&i.AvgRiskScore,
		&i.HighRiskCount,
		&i.AssessmentsThisMonth,
		&i.NewUsersThisMonth,
	)
	return i, err
}

const clinicAggregate = `-- name: ClinicAggregate :one
SELECT 
    (SELECT COUNT(*) FROM user_clinics uc1 WHERE uc1.clinic_id = $1)::int AS total_patients,
    (SELECT COUNT(*) FROM assessments a JOIN user_clinics uc2 ON a.user_id = uc2.user_id WHERE uc2.clinic_id = $1)::int AS total_assessments,
    COALESCE((SELECT AVG(risk_score) FROM assessments a JOIN user_clinics uc3 ON a.user_id = uc3.user_id WHERE uc3.clinic_id = $1), 0)::float8 AS avg_risk_score,
    (SELECT COUNT(*) FROM assessments a JOIN user_clinics uc4 ON a.user_id = uc4.user_id WHERE uc4.clinic_id = $1 AND a.risk_score >= 70)::int AS high_risk_count,
    (SELECT COUNT(*) FROM assessments a JOIN user_clinics uc5 ON a.user_id = uc5.user_id WHERE uc5.clinic_id = $1 AND a.created_at >= DATE_TRUNC('month', NOW()))::int AS assessments_this_month
`

type ClinicAggregateRow struct {
	TotalPatients        int32   `json:"total_patients"`
	TotalAssessments     int32   `json:"total_assessments"`
	AvgRiskScore         float64 `json:"avg_risk_score"`
	HighRiskCount        int32   `json:"high_risk_count"`
	AssessmentsThisMonth int32   `json:"assessments_this_month"`
}

func (q *Queries) ClinicAggregate(ctx context.Context, clinicID int32) (ClinicAggregateRow, error) {
	row := q.db.QueryRow(ctx, clinicAggregate, clinicID)
	var i ClinicAggregateRow
	err := row.Scan(
		&i.TotalPatients,
		&i.TotalAssessments,
		&i.AvgRiskScore,
		&i.HighRiskCount,
		&i.AssessmentsThisMonth,
	)
	return i, err
}

const createClinic = `-- name: CreateClinic :one
INSERT INTO clinics (name, address)
VALUES ($1, $2)
RETURNING id, name, address, created_at, updated_at
`

type CreateClinicParams struct {
	Name    string      `json:"name"`
	Address pgtype.Text `json:"address"`
}

func (q *Queries) CreateClinic(ctx context.Context, arg CreateClinicParams) (Clinic, error) {
	row := q.db.QueryRow(ctx, createClinic, arg.Name, arg.Address)
	var i Clinic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteClinic = `-- name: DeleteClinic :exec
DELETE FROM clinics WHERE id = $1
`

func (q *Queries) DeleteClinic(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteClinic, id)
	return err
}

const getClinic = `-- name: GetClinic :one
SELECT id, name, address, created_at, updated_at
FROM clinics
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetClinic(ctx context.Context, id int32) (Clinic, error) {
	row := q.db.QueryRow(ctx, getClinic, id)
	var i Clinic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const isClinicAdmin = `-- name: IsClinicAdmin :one
SELECT EXISTS(
    SELECT 1 FROM user_clinics 
    WHERE user_id = $1 AND clinic_id = $2 AND role = 'admin'
)
`

type IsClinicAdminParams struct {
	UserID   int32 `json:"user_id"`
	ClinicID int32 `json:"clinic_id"`
}

func (q *Queries) IsClinicAdmin(ctx context.Context, arg IsClinicAdminParams) (bool, error) {
	row := q.db.QueryRow(ctx, isClinicAdmin, arg.UserID, arg.ClinicID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listClinics = `-- name: ListClinics :many

SELECT id, name, address, created_at, updated_at
FROM clinics
ORDER BY name
`

// clinics.sql: SQLC queries for clinic management
func (q *Queries) ListClinics(ctx context.Context) ([]Clinic, error) {
	rows, err := q.db.Query(ctx, listClinics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Clinic
	for rows.Next() {
		var i Clinic
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserClinics = `-- name: ListUserClinics :many
SELECT c.id, c.name, c.address, c.created_at, c.updated_at, uc.role
FROM clinics c
JOIN user_clinics uc ON c.id = uc.clinic_id
WHERE uc.user_id = $1
ORDER BY c.name
`

type ListUserClinicsRow struct {
	ID        int32              `json:"id"`
	Name      string             `json:"name"`
	Address   pgtype.Text        `json:"address"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	Role      string             `json:"role"`
}

func (q *Queries) ListUserClinics(ctx context.Context, userID int32) ([]ListUserClinicsRow, error) {
	rows, err := q.db.Query(ctx, listUserClinics, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserClinicsRow
	for rows.Next() {
		var i ListUserClinicsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClinic = `-- name: UpdateClinic :one
UPDATE clinics
SET name = $2, address = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, name, address, created_at, updated_at
`

type UpdateClinicParams struct {
	ID      int32       `json:"id"`
	Name    string      `json:"name"`
	Address pgtype.Text `json:"address"`
}

func (q *Queries) UpdateClinic(ctx context.Context, arg UpdateClinicParams) (Clinic, error) {
	row := q.db.QueryRow(ctx, updateClinic, arg.ID, arg.Name, arg.Address)
	var i Clinic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
