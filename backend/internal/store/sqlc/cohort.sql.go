// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cohort.sql

package sqlcgen

import (
	"context"
)

const adminClinicComparison = `-- name: AdminClinicComparison :many
SELECT 
    c.id AS clinic_id,
    c.name AS clinic_name,
    COUNT(DISTINCT p.id)::int AS patient_count,
    COUNT(a.id)::int AS assessment_count,
    COALESCE(AVG(a.risk_score), 0)::float8 AS avg_risk_score,
    COUNT(CASE WHEN a.risk_score >= 67 THEN 1 END)::int AS high_risk_count
FROM clinics c
LEFT JOIN user_clinics uc ON c.id = uc.clinic_id
LEFT JOIN patients p ON p.user_id = uc.user_id
LEFT JOIN assessments a ON a.patient_id = p.id
GROUP BY c.id, c.name
ORDER BY patient_count DESC
`

type AdminClinicComparisonRow struct {
	ClinicID        int32   `json:"clinic_id"`
	ClinicName      string  `json:"clinic_name"`
	PatientCount    int32   `json:"patient_count"`
	AssessmentCount int32   `json:"assessment_count"`
	AvgRiskScore    float64 `json:"avg_risk_score"`
	HighRiskCount   int32   `json:"high_risk_count"`
}

func (q *Queries) AdminClinicComparison(ctx context.Context) ([]AdminClinicComparisonRow, error) {
	rows, err := q.db.Query(ctx, adminClinicComparison)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminClinicComparisonRow
	for rows.Next() {
		var i AdminClinicComparisonRow
		if err := rows.Scan(
			&i.ClinicID,
			&i.ClinicName,
			&i.PatientCount,
			&i.AssessmentCount,
			&i.AvgRiskScore,
			&i.HighRiskCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminSystemStats = `-- name: AdminSystemStats :one
SELECT 
    (SELECT COUNT(*)::int FROM users) AS total_users,
    (SELECT COUNT(*)::int FROM patients) AS total_patients,
    (SELECT COUNT(*)::int FROM assessments) AS total_assessments,
    (SELECT COUNT(*)::int FROM clinics) AS total_clinics,
    COALESCE((SELECT AVG(risk_score) FROM assessments), 0)::float8 AS avg_risk_score,
    (SELECT COUNT(*)::int FROM assessments WHERE risk_score >= 67) AS high_risk_count,
    (SELECT COUNT(*)::int FROM assessments WHERE created_at >= date_trunc('month', CURRENT_DATE)) AS assessments_this_month,
    (SELECT COUNT(*)::int FROM users WHERE created_at >= date_trunc('month', CURRENT_DATE)) AS new_users_this_month
`

type AdminSystemStatsRow struct {
	TotalUsers           int32   `json:"total_users"`
	TotalPatients        int32   `json:"total_patients"`
	TotalAssessments     int32   `json:"total_assessments"`
	TotalClinics         int32   `json:"total_clinics"`
	AvgRiskScore         float64 `json:"avg_risk_score"`
	HighRiskCount        int32   `json:"high_risk_count"`
	AssessmentsThisMonth int32   `json:"assessments_this_month"`
	NewUsersThisMonth    int32   `json:"new_users_this_month"`
}

func (q *Queries) AdminSystemStats(ctx context.Context) (AdminSystemStatsRow, error) {
	row := q.db.QueryRow(ctx, adminSystemStats)
	var i AdminSystemStatsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.TotalPatients,
		&i.TotalAssessments,
		&i.TotalClinics,
		&i.AvgRiskScore,
		&i.HighRiskCount,
		&i.AssessmentsThisMonth,
		&i.NewUsersThisMonth,
	)
	return i, err
}

const clinicAggregate = `-- name: ClinicAggregate :one
SELECT 
    COUNT(DISTINCT p.id)::int AS total_patients,
    COUNT(a.id)::int AS total_assessments,
    COALESCE(AVG(a.risk_score), 0)::float8 AS avg_risk_score,
    COUNT(CASE WHEN a.risk_score >= 67 THEN 1 END)::int AS high_risk_count,
    COUNT(CASE WHEN a.created_at >= date_trunc('month', CURRENT_DATE) THEN 1 END)::int AS assessments_this_month
FROM patients p
LEFT JOIN assessments a ON a.patient_id = p.id
WHERE p.user_id IN (SELECT user_id FROM user_clinics WHERE clinic_id = $1)
`

type ClinicAggregateRow struct {
	TotalPatients        int32   `json:"total_patients"`
	TotalAssessments     int32   `json:"total_assessments"`
	AvgRiskScore         float64 `json:"avg_risk_score"`
	HighRiskCount        int32   `json:"high_risk_count"`
	AssessmentsThisMonth int32   `json:"assessments_this_month"`
}

func (q *Queries) ClinicAggregate(ctx context.Context, clinicID int32) (ClinicAggregateRow, error) {
	row := q.db.QueryRow(ctx, clinicAggregate, clinicID)
	var i ClinicAggregateRow
	err := row.Scan(
		&i.TotalPatients,
		&i.TotalAssessments,
		&i.AvgRiskScore,
		&i.HighRiskCount,
		&i.AssessmentsThisMonth,
	)
	return i, err
}

const clinicCliniciansCount = `-- name: ClinicCliniciansCount :one
SELECT COUNT(*)::int AS count
FROM user_clinics
WHERE clinic_id = $1
`

func (q *Queries) ClinicCliniciansCount(ctx context.Context, clinicID int32) (int32, error) {
	row := q.db.QueryRow(ctx, clinicCliniciansCount, clinicID)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const cohortStatsByAgeGroup = `-- name: CohortStatsByAgeGroup :many
SELECT 
    CASE 
        WHEN p.age < 45 THEN 'Under 45'
        WHEN p.age >= 45 AND p.age < 55 THEN '45-54'
        WHEN p.age >= 55 AND p.age < 65 THEN '55-64'
        ELSE '65+'
    END AS group_name,
    COUNT(*)::int AS count,
    COALESCE(AVG(a.hba1c), 0)::float8 AS avg_hba1c,
    COALESCE(AVG(a.fbs), 0)::float8 AS avg_fbs,
    COALESCE(AVG(a.bmi), 0)::float8 AS avg_bmi,
    COALESCE(AVG(a.systolic), 0)::float8 AS avg_bp_systolic,
    COALESCE(AVG(a.diastolic), 0)::float8 AS avg_bp_diastolic,
    COALESCE(AVG(a.risk_score), 0)::float8 AS avg_risk_score
FROM assessments a
JOIN patients p ON a.patient_id = p.id
GROUP BY 
    CASE 
        WHEN p.age < 45 THEN 'Under 45'
        WHEN p.age >= 45 AND p.age < 55 THEN '45-54'
        WHEN p.age >= 55 AND p.age < 65 THEN '55-64'
        ELSE '65+'
    END
`

type CohortStatsByAgeGroupRow struct {
	GroupName      string  `json:"group_name"`
	Count          int32   `json:"count"`
	AvgHba1c       float64 `json:"avg_hba1c"`
	AvgFbs         float64 `json:"avg_fbs"`
	AvgBmi         float64 `json:"avg_bmi"`
	AvgBpSystolic  float64 `json:"avg_bp_systolic"`
	AvgBpDiastolic float64 `json:"avg_bp_diastolic"`
	AvgRiskScore   float64 `json:"avg_risk_score"`
}

func (q *Queries) CohortStatsByAgeGroup(ctx context.Context) ([]CohortStatsByAgeGroupRow, error) {
	rows, err := q.db.Query(ctx, cohortStatsByAgeGroup)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CohortStatsByAgeGroupRow
	for rows.Next() {
		var i CohortStatsByAgeGroupRow
		if err := rows.Scan(
			&i.GroupName,
			&i.Count,
			&i.AvgHba1c,
			&i.AvgFbs,
			&i.AvgBmi,
			&i.AvgBpSystolic,
			&i.AvgBpDiastolic,
			&i.AvgRiskScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cohortStatsByCluster = `-- name: CohortStatsByCluster :many

SELECT 
    COALESCE(cluster, 'Unknown') AS group_name,
    COUNT(*)::int AS count,
    COALESCE(AVG(hba1c), 0)::float8 AS avg_hba1c,
    COALESCE(AVG(fbs), 0)::float8 AS avg_fbs,
    COALESCE(AVG(bmi), 0)::float8 AS avg_bmi,
    COALESCE(AVG(systolic), 0)::float8 AS avg_bp_systolic,
    COALESCE(AVG(diastolic), 0)::float8 AS avg_bp_diastolic,
    COALESCE(AVG(risk_score), 0)::float8 AS avg_risk_score,
    COUNT(CASE WHEN risk_score < 34 THEN 1 END)::int AS low_risk_count,
    COUNT(CASE WHEN risk_score >= 34 AND risk_score < 67 THEN 1 END)::int AS moderate_risk_count,
    COUNT(CASE WHEN risk_score >= 67 THEN 1 END)::int AS high_risk_count
FROM assessments
GROUP BY COALESCE(cluster, 'Unknown')
`

type CohortStatsByClusterRow struct {
	GroupName         string  `json:"group_name"`
	Count             int32   `json:"count"`
	AvgHba1c          float64 `json:"avg_hba1c"`
	AvgFbs            float64 `json:"avg_fbs"`
	AvgBmi            float64 `json:"avg_bmi"`
	AvgBpSystolic     float64 `json:"avg_bp_systolic"`
	AvgBpDiastolic    float64 `json:"avg_bp_diastolic"`
	AvgRiskScore      float64 `json:"avg_risk_score"`
	LowRiskCount      int32   `json:"low_risk_count"`
	ModerateRiskCount int32   `json:"moderate_risk_count"`
	HighRiskCount     int32   `json:"high_risk_count"`
}

// cohort.sql: SQLC queries for cohort analysis and aggregate statistics
func (q *Queries) CohortStatsByCluster(ctx context.Context) ([]CohortStatsByClusterRow, error) {
	rows, err := q.db.Query(ctx, cohortStatsByCluster)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CohortStatsByClusterRow
	for rows.Next() {
		var i CohortStatsByClusterRow
		if err := rows.Scan(
			&i.GroupName,
			&i.Count,
			&i.AvgHba1c,
			&i.AvgFbs,
			&i.AvgBmi,
			&i.AvgBpSystolic,
			&i.AvgBpDiastolic,
			&i.AvgRiskScore,
			&i.LowRiskCount,
			&i.ModerateRiskCount,
			&i.HighRiskCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cohortStatsByMenopauseStatus = `-- name: CohortStatsByMenopauseStatus :many
SELECT 
    COALESCE(p.menopause_status, 'Unknown') AS group_name,
    COUNT(*)::int AS count,
    COALESCE(AVG(a.hba1c), 0)::float8 AS avg_hba1c,
    COALESCE(AVG(a.fbs), 0)::float8 AS avg_fbs,
    COALESCE(AVG(a.bmi), 0)::float8 AS avg_bmi,
    COALESCE(AVG(a.systolic), 0)::float8 AS avg_bp_systolic,
    COALESCE(AVG(a.diastolic), 0)::float8 AS avg_bp_diastolic,
    COALESCE(AVG(a.risk_score), 0)::float8 AS avg_risk_score
FROM assessments a
JOIN patients p ON a.patient_id = p.id
GROUP BY COALESCE(p.menopause_status, 'Unknown')
`

type CohortStatsByMenopauseStatusRow struct {
	GroupName      string  `json:"group_name"`
	Count          int32   `json:"count"`
	AvgHba1c       float64 `json:"avg_hba1c"`
	AvgFbs         float64 `json:"avg_fbs"`
	AvgBmi         float64 `json:"avg_bmi"`
	AvgBpSystolic  float64 `json:"avg_bp_systolic"`
	AvgBpDiastolic float64 `json:"avg_bp_diastolic"`
	AvgRiskScore   float64 `json:"avg_risk_score"`
}

func (q *Queries) CohortStatsByMenopauseStatus(ctx context.Context) ([]CohortStatsByMenopauseStatusRow, error) {
	rows, err := q.db.Query(ctx, cohortStatsByMenopauseStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CohortStatsByMenopauseStatusRow
	for rows.Next() {
		var i CohortStatsByMenopauseStatusRow
		if err := rows.Scan(
			&i.GroupName,
			&i.Count,
			&i.AvgHba1c,
			&i.AvgFbs,
			&i.AvgBmi,
			&i.AvgBpSystolic,
			&i.AvgBpDiastolic,
			&i.AvgRiskScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cohortStatsByRiskLevel = `-- name: CohortStatsByRiskLevel :many
SELECT 
    CASE 
        WHEN risk_score < 34 THEN 'Low'
        WHEN risk_score >= 34 AND risk_score < 67 THEN 'Moderate'
        ELSE 'High'
    END AS group_name,
    COUNT(*)::int AS count,
    COALESCE(AVG(hba1c), 0)::float8 AS avg_hba1c,
    COALESCE(AVG(fbs), 0)::float8 AS avg_fbs,
    COALESCE(AVG(bmi), 0)::float8 AS avg_bmi,
    COALESCE(AVG(systolic), 0)::float8 AS avg_bp_systolic,
    COALESCE(AVG(diastolic), 0)::float8 AS avg_bp_diastolic,
    COALESCE(AVG(risk_score), 0)::float8 AS avg_risk_score
FROM assessments
GROUP BY 
    CASE 
        WHEN risk_score < 34 THEN 'Low'
        WHEN risk_score >= 34 AND risk_score < 67 THEN 'Moderate'
        ELSE 'High'
    END
`

type CohortStatsByRiskLevelRow struct {
	GroupName      string  `json:"group_name"`
	Count          int32   `json:"count"`
	AvgHba1c       float64 `json:"avg_hba1c"`
	AvgFbs         float64 `json:"avg_fbs"`
	AvgBmi         float64 `json:"avg_bmi"`
	AvgBpSystolic  float64 `json:"avg_bp_systolic"`
	AvgBpDiastolic float64 `json:"avg_bp_diastolic"`
	AvgRiskScore   float64 `json:"avg_risk_score"`
}

func (q *Queries) CohortStatsByRiskLevel(ctx context.Context) ([]CohortStatsByRiskLevelRow, error) {
	rows, err := q.db.Query(ctx, cohortStatsByRiskLevel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CohortStatsByRiskLevelRow
	for rows.Next() {
		var i CohortStatsByRiskLevelRow
		if err := rows.Scan(
			&i.GroupName,
			&i.Count,
			&i.AvgHba1c,
			&i.AvgFbs,
			&i.AvgBmi,
			&i.AvgBpSystolic,
			&i.AvgBpDiastolic,
			&i.AvgRiskScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const totalAssessmentCount = `-- name: TotalAssessmentCount :one
SELECT COUNT(*)::int AS count FROM assessments
`

func (q *Queries) TotalAssessmentCount(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, totalAssessmentCount)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const totalPatientCount = `-- name: TotalPatientCount :one
SELECT COUNT(*)::int AS count FROM patients
`

func (q *Queries) TotalPatientCount(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, totalPatientCount)
	var count int32
	err := row.Scan(&count)
	return count, err
}
