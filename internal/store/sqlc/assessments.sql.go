// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: assessments.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clusterCounts = `-- name: ClusterCounts :many
SELECT COALESCE(cluster, '') AS cluster, COUNT(*) AS count
FROM assessments
GROUP BY COALESCE(cluster, '')
`

type ClusterCountsRow struct {
	Cluster string `json:"cluster"`
	Count   int64  `json:"count"`
}

func (q *Queries) ClusterCounts(ctx context.Context) ([]ClusterCountsRow, error) {
	rows, err := q.db.Query(ctx, clusterCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClusterCountsRow
	for rows.Next() {
		var i ClusterCountsRow
		if err := rows.Scan(&i.Cluster, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createAssessment = `-- name: CreateAssessment :one
INSERT INTO assessments (
  patient_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
  activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
  model_version, dataset_hash, validation_status
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9,
  $10, $11, $12, $13, $14, $15, $16, $17,
  $18, $19, $20
)
RETURNING id, patient_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
          activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
          model_version, dataset_hash, validation_status, created_at
`

type CreateAssessmentParams struct {
	PatientID        pgtype.Int4    `json:"patient_id"`
	Fbs              pgtype.Numeric `json:"fbs"`
	Hba1c            pgtype.Numeric `json:"hba1c"`
	Cholesterol      pgtype.Int4    `json:"cholesterol"`
	Ldl              pgtype.Int4    `json:"ldl"`
	Hdl              pgtype.Int4    `json:"hdl"`
	Triglycerides    pgtype.Int4    `json:"triglycerides"`
	Systolic         pgtype.Int4    `json:"systolic"`
	Diastolic        pgtype.Int4    `json:"diastolic"`
	Activity         pgtype.Text    `json:"activity"`
	HistoryFlag      pgtype.Bool    `json:"history_flag"`
	Smoking          pgtype.Text    `json:"smoking"`
	Hypertension     pgtype.Text    `json:"hypertension"`
	HeartDisease     pgtype.Text    `json:"heart_disease"`
	Bmi              pgtype.Numeric `json:"bmi"`
	Cluster          pgtype.Text    `json:"cluster"`
	RiskScore        pgtype.Int4    `json:"risk_score"`
	ModelVersion     pgtype.Text    `json:"model_version"`
	DatasetHash      pgtype.Text    `json:"dataset_hash"`
	ValidationStatus pgtype.Text    `json:"validation_status"`
}

func (q *Queries) CreateAssessment(ctx context.Context, arg CreateAssessmentParams) (Assessment, error) {
	row := q.db.QueryRow(ctx, createAssessment,
		arg.PatientID,
		arg.Fbs,
		arg.Hba1c,
		arg.Cholesterol,
		arg.Ldl,
		arg.Hdl,
		arg.Triglycerides,
		arg.Systolic,
		arg.Diastolic,
		arg.Activity,
		arg.HistoryFlag,
		arg.Smoking,
		arg.Hypertension,
		arg.HeartDisease,
		arg.Bmi,
		arg.Cluster,
		arg.RiskScore,
		arg.ModelVersion,
		arg.DatasetHash,
		arg.ValidationStatus,
	)
	var i Assessment
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.Fbs,
		&i.Hba1c,
		&i.Cholesterol,
		&i.Ldl,
		&i.Hdl,
		&i.Triglycerides,
		&i.Systolic,
		&i.Diastolic,
		&i.Activity,
		&i.HistoryFlag,
		&i.Smoking,
		&i.Hypertension,
		&i.HeartDisease,
		&i.Bmi,
		&i.Cluster,
		&i.RiskScore,
		&i.ModelVersion,
		&i.DatasetHash,
		&i.ValidationStatus,
		&i.CreatedAt,
	)
	return i, err
}

const listAssessmentsByPatient = `-- name: ListAssessmentsByPatient :many
SELECT id, patient_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
       activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
       model_version, dataset_hash, validation_status, created_at
FROM assessments
WHERE patient_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAssessmentsByPatient(ctx context.Context, patientID pgtype.Int4) ([]Assessment, error) {
	rows, err := q.db.Query(ctx, listAssessmentsByPatient, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Assessment
	for rows.Next() {
		var i Assessment
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.Fbs,
			&i.Hba1c,
			&i.Cholesterol,
			&i.Ldl,
			&i.Hdl,
			&i.Triglycerides,
			&i.Systolic,
			&i.Diastolic,
			&i.Activity,
			&i.HistoryFlag,
			&i.Smoking,
			&i.Hypertension,
			&i.HeartDisease,
			&i.Bmi,
			&i.Cluster,
			&i.RiskScore,
			&i.ModelVersion,
			&i.DatasetHash,
			&i.ValidationStatus,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssessmentsLimited = `-- name: ListAssessmentsLimited :many
SELECT id, patient_id, fbs, hba1c, cholesterol, ldl, hdl, triglycerides, systolic, diastolic,
       activity, history_flag, smoking, hypertension, heart_disease, bmi, cluster, risk_score,
       model_version, dataset_hash, validation_status, created_at
FROM assessments
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) ListAssessmentsLimited(ctx context.Context, limit int32) ([]Assessment, error) {
	rows, err := q.db.Query(ctx, listAssessmentsLimited, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Assessment
	for rows.Next() {
		var i Assessment
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.Fbs,
			&i.Hba1c,
			&i.Cholesterol,
			&i.Ldl,
			&i.Hdl,
			&i.Triglycerides,
			&i.Systolic,
			&i.Diastolic,
			&i.Activity,
			&i.HistoryFlag,
			&i.Smoking,
			&i.Hypertension,
			&i.HeartDisease,
			&i.Bmi,
			&i.Cluster,
			&i.RiskScore,
			&i.ModelVersion,
			&i.DatasetHash,
			&i.ValidationStatus,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const trendAverages = `-- name: TrendAverages :many
SELECT to_char(created_at, 'YYYY-MM') AS label,
       COALESCE(avg(hba1c), 0)::float8 AS hba1c,
       COALESCE(avg(fbs), 0)::float8 AS fbs
FROM assessments
GROUP BY label
ORDER BY label
`

type TrendAveragesRow struct {
	Label string  `json:"label"`
	Hba1c float64 `json:"hba1c"`
	Fbs   float64 `json:"fbs"`
}

func (q *Queries) TrendAverages(ctx context.Context) ([]TrendAveragesRow, error) {
	rows, err := q.db.Query(ctx, trendAverages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TrendAveragesRow
	for rows.Next() {
		var i TrendAveragesRow
		if err := rows.Scan(&i.Label, &i.Hba1c, &i.Fbs); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
